/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.15.v202501031619.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V0_COMMONAPI_APP_APP_HPP_
#define V0_COMMONAPI_APP_APP_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/Export.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v0 {
namespace commonapi {
namespace app {

class App {
public:
    virtual ~App() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    static const CommonAPI::Serial BASESTRUCT_SERIAL = 0xA59396C5;
    static const CommonAPI::Serial DERIVED1_SERIAL = 0x3CD0E58;
    static const CommonAPI::Serial DERIVED2_SERIAL = 0x25B835CF;
    
    struct BaseStruct : CommonAPI::PolymorphicStruct {
        static COMMONAPI_EXPORT std::shared_ptr< BaseStruct> create(CommonAPI::Serial _serial);
        CommonAPI::Serial getSerial() const { return BASESTRUCT_SERIAL; }
    
        BaseStruct()
        {
            std::get< 0>(values_) = 0;
        }
        BaseStruct(const int16_t &_a)
        {
            std::get< 0>(values_) = _a;
        }
        template<class _Input>
        void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
            _input.template readValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template readValue<_Input>(_input, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template readValue<_Input>(_input, _depl);
                break;
            default:
                break;
            }
        }
    
        template<class _Input, class _Deployment>
        void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
            _input.template readValue<>(std::get< 0>(values_), std::get< 0>(_depl->values_));
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template readValue<>(_input, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template readValue<>(_input, _depl);
                break;
            default:
                break;
            }
        }
        template<class _Output>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            _output.writeType(std::get< 0>(values_), _depl);
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template writeType<_Output>(_output, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template writeType<_Output>(_output, _depl);
                break;
            default:
                break;
            }
        }
        template<class _Output, class _Deployment>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.writeType(std::get< 0>(values_), std::get< 0>(_depl->values_));
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template writeType<_Output, _Deployment>(_output, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template writeType<_Output, _Deployment>(_output, _depl);
                break;
            default:
                break;
            }
        }
    
        template<class _Output>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            _output.template writeValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template writeValue<_Output>(_output, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template writeValue<_Output>(_output, _depl);
                break;
            default:
                break;
            }
        }
    
        template<class _Output, class _Deployment>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.template writeValue<>(std::get< 0>(values_), std::get< 0>(_depl->values_));
            switch (getSerial()) {
            case DERIVED1_SERIAL:
                static_cast< Derived1 *>(this)->template writeValue<>(_output, _depl);
                break;
            case DERIVED2_SERIAL:
                static_cast< Derived2 *>(this)->template writeValue<>(_output, _depl);
                break;
            default:
                break;
            }
        }
        inline const int16_t &getA() const { return std::get< 0>(values_); }
        inline void setA(const int16_t &_value) { std::get< 0>(values_) = _value; }
    
        std::tuple< int16_t> values_;
        inline bool operator==(const BaseStruct& _other) const {
        return (getA() == _other.getA());
        }
        inline bool operator!=(const BaseStruct &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct Derived1 : BaseStruct {
        CommonAPI::Serial getSerial() const { return DERIVED1_SERIAL; }
    
        Derived1()
        : BaseStruct()
        {
            std::get< 0>(values_) = 0;
        }
        Derived1(const int16_t &_a, const int16_t &_b)
        : BaseStruct(_a)
        {
            std::get< 0>(values_) = _b;
        }
        template<class _Input>
        void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
            (void) _depl;
            _input.template readValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
        }
    
        template<class _Input, class _Deployment>
        void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
            _input.template readValue<>(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
        template<class _Output>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            _output.writeType(std::get< 0>(values_), _depl);
        }
        template<class _Output, class _Deployment>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.writeType(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
    
        template<class _Output>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            (void) _depl;
            _output.template writeValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
        }
    
        template<class _Output, class _Deployment>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.template writeValue<>(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
        inline const int16_t &getB() const { return std::get< 0>(values_); }
        inline void setB(const int16_t &_value) { std::get< 0>(values_) = _value; }
    
        std::tuple< int16_t> values_;
        inline bool operator==(const Derived1& _other) const {
        return (getA() == _other.getA() && getB() == _other.getB());
        }
        inline bool operator!=(const Derived1 &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct Derived2 : BaseStruct {
        CommonAPI::Serial getSerial() const { return DERIVED2_SERIAL; }
    
        Derived2()
        : BaseStruct()
        {
            std::get< 0>(values_) = "";
        }
        Derived2(const int16_t &_a, const std::string &_c)
        : BaseStruct(_a)
        {
            std::get< 0>(values_) = _c;
        }
        template<class _Input>
        void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
            (void) _depl;
            _input.template readValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
        }
    
        template<class _Input, class _Deployment>
        void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
            _input.template readValue<>(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
        template<class _Output>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            _output.writeType(std::get< 0>(values_), _depl);
        }
        template<class _Output, class _Deployment>
        void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.writeType(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
    
        template<class _Output>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
            (void) _depl;
            _output.template writeValue<CommonAPI::EmptyDeployment>(std::get< 0>(values_));
        }
    
        template<class _Output, class _Deployment>
        void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
            _output.template writeValue<>(std::get< 0>(values_), std::get< 1>(_depl->values_));
        }
        inline const std::string &getC() const { return std::get< 0>(values_); }
        inline void setC(const std::string &_value) { std::get< 0>(values_) = _value; }
    
        std::tuple< std::string> values_;
        inline bool operator==(const Derived2& _other) const {
        return (getA() == _other.getA() && getC() == _other.getC());
        }
        inline bool operator!=(const Derived2 &_other) const {
            return !((*this) == _other);
        }
    
    };
};

const char* App::getInterface() {
    return ("commonapi.app.App:v0_1");
}

CommonAPI::Version App::getInterfaceVersion() {
    return CommonAPI::Version(0, 1);
}


} // namespace app
} // namespace commonapi
} // namespace v0

namespace CommonAPI {
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COMMONAPI_APP_APP_HPP_
